package tum.laser.voicerecognizer;

import java.util.Arrays;
import java.util.LinkedList;

import android.media.AudioFormat;
import android.media.AudioRecord;
import android.media.MediaRecorder;
import android.os.Bundle;
import android.app.Activity;
import android.view.Menu;

public class MainActivity extends Activity {


	// TODO: may need to change this to 44100 sampling to make it more compatible across devices
	// Alternatively, we could dynamically discover it 
	// http://stackoverflow.com/questions/6745344/record-audio-using-audiorecord-in-android

	private static int RECORDER_SOURCE = MediaRecorder.AudioSource.VOICE_RECOGNITION;
	private static int RECORDER_CHANNELS = AudioFormat.CHANNEL_IN_MONO;
	private static int RECORDER_AUDIO_ENCODING = AudioFormat.ENCODING_PCM_16BIT;
	private static int RECORDER_SAMPLERATE = 8000;

	// 8000Hz/8192bins = 1Hz/bin freq.res.
	// 8192 samples per FFT; 8000Hz -> 1.024s
	//private static int FFT_SIZE = 8192;
	
	private static int FFT_SIZE = 512;
	//8000samples/s divided by 256samples/frame -> 32ms/frame (31.25ms)
	private static int FRAME_SIZE = 256;
	
	//32ms/frame times 64frames/window = 2s/window
	private static int WINDOW_SIZE = 64; //nothing to do with smoothing window (Hamming window)
	
	private static int MFCCS_VALUE = 12;
	private static int MEL_BANDS = 20; //use FB-20
	private static double[] FREQ_BANDEDGES = {50,250,500,1000,2000};

	private Thread recordingThread = null;
	private int bufferSize = 0;
	//private int bufferSamples = 0;
	private static int[] freqBandIdx = null;

	private FFT featureFFT = null;
	private MFCC featureMFCC = null;
	private Window featureWin = null;

	private AudioRecord audioRecorder = null;

	public double prevSecs = 0;
	public double[] featureBuffer = null;

	@Override
	protected void onStart() {
		super.onStart();


		bufferSize = AudioRecord.getMinBufferSize(
				RECORDER_SAMPLERATE,
				RECORDER_CHANNELS,
				RECORDER_AUDIO_ENCODING);

		bufferSize = Math.max(bufferSize, RECORDER_SAMPLERATE*2);
		//bufferSamples = bufferSize/2;


		//allocateFrameFeatureBuffer(STREAM_FEATURES);

		featureFFT = new FFT(FFT_SIZE);
		featureWin = new Window(FRAME_SIZE);
		featureMFCC = new MFCC(FFT_SIZE, MFCCS_VALUE, MEL_BANDS, RECORDER_SAMPLERATE);

		freqBandIdx = new int[FREQ_BANDEDGES.length];
		for (int i = 0; i < FREQ_BANDEDGES.length; i ++)
		{
			freqBandIdx[i] = Math.round((float)FREQ_BANDEDGES[i]*((float)FFT_SIZE/(float)RECORDER_SAMPLERATE));
			//writeLogTextLine("Frequency band edge " + i + ": " + Integer.toString(freqBandIdx[i]));
		}

		audioRecorder = new AudioRecord(
				RECORDER_SOURCE,
				RECORDER_SAMPLERATE,
				RECORDER_CHANNELS,
				RECORDER_AUDIO_ENCODING,
				bufferSize);
		prevSecs = (double)System.currentTimeMillis()/1000.0d;
		audioRecorder.startRecording();
		recordingThread = new Thread(new Runnable()
		{
			@Override
			public void run()
			{
				handleAudioStream();
			}
		}, "AudioRecorder Thread");
		recordingThread.start();
	}

	@Override
	protected void onStop() {
		super.onStop();
		audioRecorder.stop();
		audioRecorder.release();
		audioRecorder = null;
		recordingThread = null;
	}


	private void handleAudioStream()
	{
		short dataFrame16bit[] = new short[FRAME_SIZE];
		double fftBufferR[] = new double[FFT_SIZE];
		double fftBufferI[] = new double[FFT_SIZE];
		double featureCepstrum[] = new double[MFCCS_VALUE];
		
		LinkedList<double[][]> featureCepstrums = new LinkedList<double[][]>();
		LinkedList<double[][]> psdsAcrossFrequencyBands = new LinkedList<double[][]>();
		
		//alle 64 durchlŠufe neu anlegen:
		double[][] cepstrumWindow = new double[64][];

		int readAudioSamples = 0;
		
		//# of iterations (~seconds)
		int it = 1000;
		
		while (it-- > 0)
		{
			// read() kann entweder mind. buffer_size/2 zeichen zurŸckliefern
			// (wir brauchen viel weniger) oder blockiert:
			// http://stackoverflow.com/questions/15804903/android-dev-audiorecord-without-blocking-or-threads
			readAudioSamples = audioRecorder.read(dataFrame16bit, 0, FRAME_SIZE);
			double currentSecs = (double)(System.currentTimeMillis())/1000.0d;
			double diffSecs = currentSecs - prevSecs;
			prevSecs = currentSecs;
			
			if (readAudioSamples > 0)
			{
				double fN = (double)readAudioSamples;

				//data.add("diff_s", diffSecs);

				// L1-norm
				double accum = 0;
				for (int i = 0; i < readAudioSamples; i ++)
				{
					accum += Math.abs((double)dataFrame16bit[i]);
				}
				//data.put("L1N", accum/fN);

				// L2-norm
				accum = 0;
				for (int i = 0; i < readAudioSamples; i ++)
				{
					accum += (double)dataFrame16bit[i]*(double)dataFrame16bit[i];
				}
				//data.put("L2N", Math.sqrt(accum/fN));

				// Linf-norm
				accum = 0;
				for (int i = 0; i < readAudioSamples; i ++)
				{
					accum = Math.max(Math.abs((double)dataFrame16bit[i]),accum);
				}
				//data.put("LN", Math.sqrt(accum));

				// Frequency analysis
				Arrays.fill(fftBufferR, 0);
				Arrays.fill(fftBufferI, 0);

				// Convert audio buffer to doubles
				for (int i = 0; i < readAudioSamples; i++)
				{
					fftBufferR[i] = dataFrame16bit[i];
				}

				// In-place windowing
				featureWin.applyWindow(fftBufferR);

				// In-place FFT
				featureFFT.fft(fftBufferR, fftBufferI);

				// Get PSD across frequency band ranges
				double[] psdAcrossFrequencyBands = new double[FREQ_BANDEDGES.length - 1];
				for (int b = 0; b < (FREQ_BANDEDGES.length - 1); b ++)
				{
					int j = freqBandIdx[b];
					int k = freqBandIdx[b+1];
					accum = 0;
					for (int h = j; h < k; h ++)
					{
						accum += fftBufferR[h]*fftBufferR[h] + fftBufferI[h]*fftBufferI[h];
					}
					psdAcrossFrequencyBands[b] = accum/((double)(k - j));
				}
				//new:
				psdsAcrossFrequencyBands.add(psdAcrossFrequencyBands);

				// Get MFCCs
				featureCepstrum = featureMFCC.cepstrum(fftBufferR, fftBufferI);
				//new:
				featureCepstrums.add(featureCepstrum);
				//data.add("mfcc", gson.toJsonTree(featureCepstrum));

				// Write out features
				//sendData(data);

			} else {
				return;
			}
		}
		return;
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		// Inflate the menu; this adds items to the action bar if it is present.
		getMenuInflater().inflate(R.menu.main, menu);
		return true;
	}

}
